# AI Counselor Context Architecture

## Overview

The AI counselor (Sesame) requires context to be effective. This document describes how context is assembled, managed, and updated across conversations.

## Context Components

### 1. Profile Narrative
- **What**: Text summary of student's current profile (GPA, testing, activities, schools, etc.)
- **Source**: Generated from `StudentProfile` and related tables
- **Update trigger**: Regenerated when conversation starts
- **Token budget**: ~300 tokens

### 2. Conversation Summary (Long-term Memory)
- **What**: Rolling summary of past conversations - key facts learned, decisions made, open threads, emotional context
- **Source**: Stored in `StudentContext` table, updated after each session
- **Update trigger**: When previous session ends (on new page load, after inactivity)
- **Token budget**: ~200 tokens

### 3. Entry Context
- **What**: Where the user came from (onboarding, planning page, dashboard, etc.) and any initial query
- **Source**: URL params, referrer
- **Update trigger**: Set at conversation start
- **Token budget**: ~50 tokens

### 4. Counselor Objectives
- **What**: Prep sheet for the AI - priority questions, things to check on, updates to share
- **Source**: Generated by background process, stored in DB
- **Update triggers**:
  - After each session ends (prepare for next)
  - Daily cron job (deadline awareness, time-based updates)
  - When significant profile data changes
- **Token budget**: ~100 tokens

### 5. Conversation State (Current Session)
- **What**: What's happened so far this session - topics covered, pending confirmations, emotional tone
- **Source**: Built dynamically each turn from current session messages
- **Update trigger**: Every AI call
- **Token budget**: ~100 tokens

## Session Lifecycle

```
Page Load
    │
    ├── Is there a previous unsummarized session?
    │   └── Yes → Summarize it, update Conversation Summary
    │
    ├── Load all context components
    │
    └── Start new session
            │
            ├── User sends message
            │   ├── Assemble system prompt (all 5 components)
            │   ├── Call AI with messages
            │   ├── Process tool calls → show widgets
            │   └── Update Conversation State
            │
            └── Session ends (inactivity / page unload)
                ├── Summarize session → update Conversation Summary
                └── Regenerate Counselor Objectives
```

## System Prompt Assembly

```
System Prompt = [
  BASE_PERSONA,           // Core personality and instructions
  PROFILE_NARRATIVE,      // Current student profile summary
  CONVERSATION_SUMMARY,   // Past conversations summary
  ENTRY_CONTEXT,          // How they got here
  COUNSELOR_OBJECTIVES,   // What to accomplish
  CONVERSATION_STATE,     // This session so far
  TOOL_INSTRUCTIONS,      // Available tools and how to use them
]
```

## Background Jobs

| Job | Trigger | Purpose |
|-----|---------|---------|
| Session Summarizer | Page load (lazy) or 5min inactivity | Compress completed session into long-term memory |
| Objectives Generator | Session end, daily cron, profile update | Prepare AI for next conversation |

## Token Budget Summary

| Component | Budget |
|-----------|--------|
| Profile Narrative | ~300 |
| Conversation Summary | ~200 |
| Counselor Objectives | ~100 |
| Entry Context | ~50 |
| Conversation State | ~100 |
| **Total Overhead** | **~750 tokens** |

## Key Design Decisions

1. **Lazy summarization**: Previous session is summarized when new session starts, not immediately after session ends
2. **Hybrid state management**: React state for UI (widgets), system prompt for AI context
3. **Proactive objectives**: AI comes prepared with goals, not just reactive to user
4. **Narrative over JSON**: Profile context is human-readable text for the AI, not raw JSON
